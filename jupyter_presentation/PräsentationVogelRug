{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Performance-tests to determine better strategies"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Performance-test #1: using Arrays of Arrays vs 3 dimensional Arrays"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### two little examples"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 121,
   "metadata": {
    "collapsed": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "2-element Array{Array{Float64,2},1}:\n",
       " [1.0 0.0; 0.0 1.0]\n",
       " [1.0 2.0; 3.0 4.0]"
      ]
     },
     "execution_count": 121,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "ArrayA= [[1.0 0.0;0.0 1.0],[1.0 2.0;3.0 4.0]]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "It is now a vector and its entries are matrices"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 122,
   "metadata": {
    "collapsed": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "2×2 Array{Float64,2}:\n",
       " 1.0  0.0\n",
       " 0.0  1.0"
      ]
     },
     "execution_count": 122,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "ArrayA[1]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 123,
   "metadata": {
    "collapsed": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "2×2 Array{Float64,2}:\n",
       " 1.0  0.0\n",
       " 0.0  1.0"
      ]
     },
     "execution_count": 123,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "Array3d= Array{Float64,3}(undef,2,2,2)\n",
    "Array3d[1,:,:]=[1.0 0.0;0.0 1.0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 124,
   "metadata": {
    "collapsed": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "2×2 Array{Float64,2}:\n",
       " 1.0  2.0\n",
       " 3.0  4.0"
      ]
     },
     "execution_count": 124,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "Array3d[2,:,:]=[1.0 2.0;3.0 4.0]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "basically the same Array:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 125,
   "metadata": {
    "collapsed": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "true"
      ]
     },
     "execution_count": 125,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "(Array3d[1,:,:]==ArrayA[1][:,:]) && (Array3d[2,:,:]==ArrayA[2][:,:])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### defining two test-functions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "actual code iterates over every index and does a simple operation, so the test-functions should do the same"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### test Arrays of Arrays"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 126,
   "metadata": {
    "collapsed": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "arrayarray (generic function with 1 method)"
      ]
     },
     "execution_count": 126,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "function arrayarray(A::Array{Array{Float64,2},1}, B::Array{Array{Float64,2},1})\n",
    "    sum=0.0;\n",
    "    for k in 1:size(A[1])[2]\n",
    "        for l in 1:size(A[1])[1]\n",
    "            for j=1:length(B)\n",
    "                for i=1:length(A)\n",
    "                    sum+=A[i][l,k]*B[j][l,k]\n",
    "                end\n",
    "            end\n",
    "        end\n",
    "    end\n",
    " return sum;\n",
    "end"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### test 3 dimensional Arrays"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 127,
   "metadata": {
    "collapsed": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array3d (generic function with 1 method)"
      ]
     },
     "execution_count": 127,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "function array3d(A::Array{Float64,3}, B::Array{Float64,3})\n",
    "    sum=0.0;\n",
    "    for k in 1:size(A)[3]\n",
    "        for l in 1:size(A)[2]\n",
    "            for i=1:size(A)[1]\n",
    "                for j=1:size(B)[1]\n",
    "                    sum+=A[i,l,k]*B[j,l,k]\n",
    "                end\n",
    "            end\n",
    "        end\n",
    "    end\n",
    " return sum;\n",
    "end"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### initialize large, equivalent Matrices to test"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "first one has random entries, second one is filled with the exact same entries"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 128,
   "metadata": {},
   "outputs": [],
   "source": [
    "A1=Array{Array{Float64,2},1}(undef,10)\n",
    "B1=Array{Array{Float64,2},1}(undef,10)\n",
    "\n",
    "A2=Array{Float64,3}(undef,10,1000,1000)\n",
    "B2=Array{Float64,3}(undef,10,1000,1000)\n",
    "\n",
    "for i in 1:10\n",
    "    A1[i]=rand(1000,1000)\n",
    "    B1[i]=rand(1000,1000)\n",
    "\n",
    "    A2[i,:,:]=A1[i]\n",
    "    B2[i,:,:]=B1[i]\n",
    "end"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### do the test"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 129,
   "metadata": {},
   "outputs": [],
   "source": [
    "using BenchmarkTools"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 130,
   "metadata": {},
   "outputs": [],
   "source": [
    "sum1=0.0; sum2=0.0;"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 131,
   "metadata": {},
   "outputs": [],
   "source": [
    "benchmarksarrayarray = @benchmark sum1=arrayarray(A1,B1);"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 132,
   "metadata": {},
   "outputs": [],
   "source": [
    "benchmarksarray3d = @benchmark sum2=array3d(A2,B2);"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "proving that both functions have the same result:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 133,
   "metadata": {
    "collapsed": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "true"
      ]
     },
     "execution_count": 133,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "sum1==sum2"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "\"old\" version:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 134,
   "metadata": {
    "collapsed": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "BenchmarkTools.Trial: \n",
       "  memory estimate:  0 bytes\n",
       "  allocs estimate:  0\n",
       "  --------------\n",
       "  minimum time:     727.746 ms (0.00% GC)\n",
       "  median time:      741.806 ms (0.00% GC)\n",
       "  mean time:        745.432 ms (0.00% GC)\n",
       "  maximum time:     775.134 ms (0.00% GC)\n",
       "  --------------\n",
       "  samples:          7\n",
       "  evals/sample:     1"
      ]
     },
     "execution_count": 134,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "benchmarksarrayarray"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "\"new\" version:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 135,
   "metadata": {
    "collapsed": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "BenchmarkTools.Trial: \n",
       "  memory estimate:  0 bytes\n",
       "  allocs estimate:  0\n",
       "  --------------\n",
       "  minimum time:     244.475 ms (0.00% GC)\n",
       "  median time:      257.407 ms (0.00% GC)\n",
       "  mean time:        255.985 ms (0.00% GC)\n",
       "  maximum time:     268.201 ms (0.00% GC)\n",
       "  --------------\n",
       "  samples:          20\n",
       "  evals/sample:     1"
      ]
     },
     "execution_count": 135,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "benchmarksarray3d"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Performance-test #2: Comparing slices to views and how to use them properly"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### defining a function to test slices"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 136,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "testslice (generic function with 1 method)"
      ]
     },
     "execution_count": 136,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "function testslice(vector,a)\n",
    "    for i in 1:1000000\n",
    "        a=vector[i:i+5];\n",
    "    end\n",
    "end"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### defining a function to test for-loops instead of slices"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 137,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "testloop (generic function with 1 method)"
      ]
     },
     "execution_count": 137,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "function testloop(vector,a)\n",
    "    for i in 1:1000000\n",
    "        for j in 0:5\n",
    "            a[j+1]=vector[i+j]\n",
    "        end\n",
    "    end\n",
    "end"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### defining a function to test @view"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 138,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "testview (generic function with 1 method)"
      ]
     },
     "execution_count": 138,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "function testview(vector)\n",
    "    for i in 1:1000000\n",
    "        a= @view vector[i:i+5];\n",
    "    end\n",
    "end"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### defining a function to test preallocating the @view"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 139,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "testpreallocview (generic function with 1 method)"
      ]
     },
     "execution_count": 139,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "function testpreallocview(vector,a)\n",
    "    for i in 1:1000000\n",
    "        a= @view vector[i:i+5];\n",
    "    end\n",
    "end"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### defining a function to test @view in combination with @inbounds"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 140,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "testviewinbounds (generic function with 1 method)"
      ]
     },
     "execution_count": 140,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "function testviewinbounds(vector)\n",
    "    for i in 1:1000000\n",
    "        a= @inbounds @views vector[i:i+5];\n",
    "    end\n",
    "end"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### initializing a testvector and preallocating a slice/@view"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 141,
   "metadata": {},
   "outputs": [],
   "source": [
    "vector = rand(1000000+5);"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 142,
   "metadata": {},
   "outputs": [],
   "source": [
    "as = vector[1:6];"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 143,
   "metadata": {},
   "outputs": [],
   "source": [
    "av = @view vector[1:6];"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### benchmarking every function"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 144,
   "metadata": {
    "collapsed": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "BenchmarkTools.Trial: \n",
       "  memory estimate:  122.07 MiB\n",
       "  allocs estimate:  1000000\n",
       "  --------------\n",
       "  minimum time:     128.201 ms (17.77% GC)\n",
       "  median time:      137.328 ms (19.69% GC)\n",
       "  mean time:        136.717 ms (19.58% GC)\n",
       "  maximum time:     145.770 ms (22.29% GC)\n",
       "  --------------\n",
       "  samples:          37\n",
       "  evals/sample:     1"
      ]
     },
     "execution_count": 144,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "@benchmark testslice(vector,as)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 145,
   "metadata": {
    "collapsed": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "BenchmarkTools.Trial: \n",
       "  memory estimate:  0 bytes\n",
       "  allocs estimate:  0\n",
       "  --------------\n",
       "  minimum time:     10.888 ms (0.00% GC)\n",
       "  median time:      11.112 ms (0.00% GC)\n",
       "  mean time:        11.717 ms (0.00% GC)\n",
       "  maximum time:     14.849 ms (0.00% GC)\n",
       "  --------------\n",
       "  samples:          426\n",
       "  evals/sample:     1"
      ]
     },
     "execution_count": 145,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "@benchmark testloop(vector,as)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 146,
   "metadata": {
    "collapsed": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "BenchmarkTools.Trial: \n",
       "  memory estimate:  0 bytes\n",
       "  allocs estimate:  0\n",
       "  --------------\n",
       "  minimum time:     1.413 ms (0.00% GC)\n",
       "  median time:      1.416 ms (0.00% GC)\n",
       "  mean time:        1.627 ms (0.00% GC)\n",
       "  maximum time:     6.578 ms (0.00% GC)\n",
       "  --------------\n",
       "  samples:          3063\n",
       "  evals/sample:     1"
      ]
     },
     "execution_count": 146,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "@benchmark testview(vector)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 147,
   "metadata": {
    "collapsed": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "BenchmarkTools.Trial: \n",
       "  memory estimate:  0 bytes\n",
       "  allocs estimate:  0\n",
       "  --------------\n",
       "  minimum time:     1.413 ms (0.00% GC)\n",
       "  median time:      1.413 ms (0.00% GC)\n",
       "  mean time:        1.479 ms (0.00% GC)\n",
       "  maximum time:     2.759 ms (0.00% GC)\n",
       "  --------------\n",
       "  samples:          3375\n",
       "  evals/sample:     1"
      ]
     },
     "execution_count": 147,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "@benchmark testpreallocview(vector,av)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 148,
   "metadata": {
    "collapsed": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "BenchmarkTools.Trial: \n",
       "  memory estimate:  0 bytes\n",
       "  allocs estimate:  0\n",
       "  --------------\n",
       "  minimum time:     46.204 ns (0.00% GC)\n",
       "  median time:      46.479 ns (0.00% GC)\n",
       "  mean time:        54.220 ns (0.00% GC)\n",
       "  maximum time:     2.986 μs (0.00% GC)\n",
       "  --------------\n",
       "  samples:          10000\n",
       "  evals/sample:     989"
      ]
     },
     "execution_count": 148,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "@benchmark testviewinbounds(vector)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "BUT @inbounds is dangerous:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 149,
   "metadata": {},
   "outputs": [],
   "source": [
    "vector=rand(10);"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 150,
   "metadata": {
    "collapsed": true
   },
   "outputs": [
    {
     "ename": "BoundsError",
     "evalue": "BoundsError: attempt to access 10-element Array{Float64,1} at index [6:11]",
     "output_type": "error",
     "traceback": [
      "BoundsError: attempt to access 10-element Array{Float64,1} at index [6:11]",
      "",
      "Stacktrace:",
      " [1] throw_boundserror(::Array{Float64,1}, ::Tuple{UnitRange{Int64}}) at ./abstractarray.jl:484",
      " [2] checkbounds at ./abstractarray.jl:449 [inlined]",
      " [3] view at ./subarray.jl:155 [inlined]",
      " [4] testview(::Array{Float64,1}) at ./In[138]:3",
      " [5] top-level scope at In[150]:1"
     ]
    }
   ],
   "source": [
    "testview(vector);"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "rewrite testviewinbounds to see what's actually happening:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 151,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "testviewinbounds (generic function with 1 method)"
      ]
     },
     "execution_count": 151,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "function testviewinbounds(vector)\n",
    "    a=@views vector[1:6];\n",
    "    for i in 1:1000000\n",
    "        a= @inbounds @views vector[i:i+5];\n",
    "    end\n",
    "    println(a);\n",
    "end"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 152,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.0, 0.0, 0.0, 2.28625e-314, 2.21417e-314, 2.29708e-314]\n"
     ]
    }
   ],
   "source": [
    "testviewinbounds(vector);"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Reducing Allocations"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Importing our module FEMCE (Finite Element Method for the compressible Euler equation):"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "import FEMCE;"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Defining a $100 \\times 50$ mesh on $\\Omega = [-50,50] \\, km \\, \\times \\, [-25,25] \\, km$:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 99,
   "metadata": {},
   "outputs": [],
   "source": [
    "m=FEMCE.generateRectMesh(100,50,-50000.0,-25000.0,50000.0,25000.0);"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 107,
   "metadata": {
    "collapsed": true
   },
   "outputs": [
    {
     "data": {
      "image/png": "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/GrTsd2Jwxrp+NemY7/jyoA3uZ89e1bz5s1TeXm5qqqqNHv2bHV2dmb0wq2trZo2bZoKCgr05JNP9vncxYsX9eijj+q6665TWVmZXnrppdTnoijS888/r5qamowXAwAAYMGgTxE2Njbq/fff1/79+1VbW6vGxsbU56Io0pEjR/p8/cWLF3X06NHUx5MnT9bLL7+spUuX9nvtzZs369ChQzpy5Ij27t2rF154QYcPH5YkrVq1Sg888EDWCwMAABgrA26wLrvsMs2ZM0d5eZduXLvtttt0/Pjx1Oc/+OAD3XnnnWpra5MkffHFF6qvr9eaNWtSX1NeXq7Kykrl5/f/U8iWlhYtWrRI48ePV3Fxse69915t3bpV7777rg4cOKB169bp2LFjevPNN50uFgAA4B9hRPdgrVu3TnPnzk19nEgk1NraqtraWv3iF7/Qq6++qsLCwj5/1DeUrq4uTZw4MfVxaWmp3nnnHd14443aunWrJGn//v264447hnydnp4enT59OvVxQUGBCgoKRvQerDwaSse/Nh3bnTiskY5/bTq2O+lNF4Y9pmHVqlV644039Pvf/16XX355n88dPHhQlZWVmjlzplpbW1M/8fqylStXqqenR6tXr05dmzp1qjZu3Kjp06dLkpqamtTR0aGNGzeO6E0nj2lIt2zZMi1fvnzI721tzVd9faH6P1Y62KOmA113fY2Of206tjtxWCMd/9p0bHciNTd/prvuujBAf3jFxcV9Pk79BKu5uVlr166VJP30pz/VQw89pNWrV2v79u166623+m2uent79fjjj2vhwoVqa2tTS0uLfvSjH43oTZSUlKizszO1wTp58qRKRvFsZHt7u6qqqlIfj+QnWBUVl/453KPAg113fY2Of206tjtxWCMd/9p0bHeS1yoqipS2Txq11Aarvr5e9fX1qU+sXbtWW7Zs0VtvvaUrrriizzf19PRo7ty5+va3v63nnntOf/nLXzRz5kz19vbqoYceGjZ6zz33aMOGDfr+97+vTz/9VC0tLdq1a1fGb37ChAkqKirK+Pskm4+G0vGrTcd2Jw5rpONfm479jisD3uTe3d2tJ554Qn//+9/1ne98R1VVVbr11ltTnz9//rzq6ur03HPPSZKuuuoqtbW1ady4/3u5PXv2KJFIaO3atdqwYYMSiYR+85vfSJJ+/OMf6/rrr1d5ebmmT5+upUuXasqXt6sAAAAeG/Am90QioaFuzfrqV7+qBQsW9Ll25ZVX6sEHH0x9XFNTo+7u7gG/f/z48WpqahrN+wUAADBv0HOwAAAAMDqx/atyrDwaSse/Nh3bnTiskY5/bTq2O+lNF4Y9psGi5DENHR0dujnDO9Ref12aPz9Hb2zMhPW3mYeH+djGfGxjPraFNZ8dO6R589y8Vux+gpU8DcLK3+Dt5jWH/9vM/VqP7XYu5uPXemx3Mm+Pbj5x+Hdpo+NuPnbX6HMnjPkkr43ixKhBxW6DlWTx0VA6frXp2O7EYY10/GvTsd9xhZvcAQAAHGODBQAA4BgbLAAAAMdiew+WlUdD6fjXpmO7E4c10vGvTcd2J73pAsc0BCGsx2TDw3xsYz62MR/bwpoPxzRkgWMafFiP7XYu5uPXemx3Mm9zTIPtThjHAITbCWM+yWsc0+CAxUdD6fjVpmO7E4c10vGvTcd+xxVucgcAAHCMDRYAAIBjbLAAAAAci+09WFYeDaXjX5uO7U4c1kjHvzYd2530pgsc0xCEsB6TDQ/zsY352MZ8bAtrPhzTkAWOafBhPbbbuZiPX+ux3cm8zTENtjthHAMQbieM+SSvcUyDAxYfDaXjV5uO7U4c1kjHvzYd+x1XuMkdAADAMTZYAAAAjrHBAgAAcCy292BZeTSUjn9tOrY7cVgjHf/adGx30psucExDEMJ6TDY8zMc25mMb87EtrPlwTEMWOKbBh/XYbudiPn6tx3Yn8zbHNNjuhHEMQLidMOaTvMYxDQ5YfDSUjl9tOrY7cVgjHf/adOx3XOEmdwAAAMfYYAEAADjGBgsAAMCx2N6DZeXRUDr+tenY7sRhjXT8a9Ox3UlvuhC7YxreeUeaPj1Hb2zMhPWYbHiYj23MxzbmY1tY83n7bWnaNDevFbufYE2bdulf4Li0Pxw9dUq65pr+Xz/QddfXsv3+Q4d6dMMNhcGsx4d2Jl870vn4sh4fOpm0s5lPHP5djnXH9XwsrtHnTkjzuXjR3eZKiuFPsEL08ccfq7i4eKzfBgbBfGxjPrYxH9uYz+C4yR0AAMAxNlgAAACOscECAABwjA2W5z7//HP927/9mz7//POxfisYAPOxjfnYxnxsYz5D4yZ3z50+fVr//M//rE8//VRFRUVj/XaQhvnYxnxsYz62MZ+h8RMsAAAAx9hgAQAAOOblQaO9vb2SpD/n4mx7z/T09EiS9u/frwkTJozxu0E65mMb87GN+djGfPr7+te/rssvv1ySp/dg/ed//qfq6urG+m0AAACkfPnecC83WB999JF2796t0tJS/dM//dNYvx0AAAD/f4IFAABgGTe5AwAAOMYGCwAAwDE2WMY8++yzysvL03vvvZfR923cuFFTp05Vfn6+XnzxxT6fO3PmjO677z6VlZWpvLxc27dvT33u3LlzeuSRR9TQ0ODi7Qfp7NmzmjdvnsrLy1VVVaXZs2ers7Mzo9dobW3VtGnTVFBQoCeffLLP5y5evKhHH31U1113ncrKyvTSSy+lPhdFkZ5//nnV1NQ4WAm+7OjRo/rmN7+p8vJy3XLLLTp06NBYv6XgZPtrh183/zij+b2H33eGxgbLkH379ul//ud/VFJS0uf6uXPndOLEiT7Xzp49q5MnT6Y+rq6u1rZt23T//ff3e93Vq1eroKBAx44d0+7du7V48WJ98sknOn/+vJ599lk9/PDDuVlQQBobG/X+++9r//79qq2tVWNjY+pzURTpyJEjfb7+4sWLOnr0aOrjyZMn6+WXX9bSpUv7vfbmzZt16NAhHTlyRHv37tULL7ygw4cPS5JWrVqlBx54IEerireFCxeqsbFRR44c0bJly7RgwYKxfktBGuzXDr9u7Bjo9x5+38keGywjPv/8cy1ZskQvvfSS8vLy+nzu4MGDuv3223XgwAFJl/6XQW1trbZs2ZL6msrKSk2ZMkXjxvUfaUtLi5YsWSJJmjRpkmbMmKGdO3eqra1N3d3dampq0t69e9XR0ZHDFfrrsssu05w5c1Jzue2223T8+PHU5z/44APdeeedamtrkyR98cUXqq+v15o1a1JfU15ersrKSuXn9z96rqWlRYsWLdL48eNVXFyse++9V1u3btW7776rAwcOaN26dTp27JjefPPNHK80Pv76179q3759qeNefvCDH+jEiRMZ/2QSQxvq1w6/bmwY7Pceft/JHhssI5555hnV1dVp0qRJ/T530003qbm5WXfffbfa29s1e/Zsfetb39JTTz01otfu6urSxIkTUx+Xlpaqq6tLs2bN0q9//Ws988wzuuWWW1RdXe1sPSFbt26d5s6dm/o4kUiotbVVjY2NeuONN3TfffepoKCgzx9ZDGWw+dx4443aunWr/v3f/11lZWW64447nK8lrk6dOqWrrroq9Rt3Xl6eSkpK1NXVNcbvLGxf/rXDrxsbBvu9h993sscGy4A//vGPevvtt7V48eJBv+Zb3/qW1q9fr5qaGlVUVGjlypUZNb78v0zST+YoLS3VK6+8ktHrxdWqVat09OhR/eu//muf61//+te1c+dOzZ8/Xz09PfrVr3414P+qG8xQ85GkPXv2jPo9Y2DpPynmxJrcGujXDr9uxtZwv/fw+0522GCNkebmZlVVVamqqkp79uzR4cOHNWnSJJWWlqq7u1uzZs3S7373u9TXf/TRR3r66ae1fPly7d69O6P/cJSUlPT5o4+TJ0/2u88LfX15Pps2bZJ06Z6C7du363e/+13qILmk3t5ePf7441q4cKFOnDihlpaWEbeYzz/eNddco+7ubl24cEHSpf/4nzp1in/vOTLYrx1+3Yyt9vb2IX/v4fedLEUwZ+LEidGBAwdSH//v//5vdOONN0a/+tWvoiiKooMHD0aTJk2Kdu3a1e97H3zwweg//uM/+lz7+c9/Hj344INRFEXR8ePHoyuvvDL629/+lrsFBGjNmjXRzTffHH388cf9PvfZZ59FNTU10YoVK6IoiqIPPvggqqioiDZu3Njva3/+859HTzzxRJ9rmzZtim6//fbowoUL0d/+9reopKQkOnToUG4WgpR/+Zd/iTZt2hRFURS99tpr0a233jq2byhQg/3a4deNPV/+vYffd7LHBsug9A1WZ2dntG3btj5f8/7770c7duxIffzqq69GV199dXT55ZdHV1xxRXT11VdH+/bti6Ioinp6eqJ77703uu6666LJkydHr7322j9mIYE4depUJCm69tpro8rKyqiysjK65ZZbUp//+OOPU/8RSvrwww+jV155JfXxf//3f0dXX311VFhYGE2YMCG6+uqro507d0ZRFEUXLlyIFi9eHF177bXRtdde2+8/VMiNw4cPR7fddls0efLkqLq6OnrvvffG+i0FZ6hfO/y6sefLv/fw+072+KtyAAAAHOMeLAAAAMfYYAEAADjGBgsAAMCx/w86cmGh3zKAFAAAAABJRU5ErkJggg=="
     },
     "execution_count": 107,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "FEMCE.plotMesh2D(m,false)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Obtaining the points and weights for the Gauß-Legendre cubature to exactly integrate polynomials of degree $\\leq 9$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 101,
   "metadata": {
    "collapsed": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "2×5 Array{Float64,2}:\n",
       " 0.0469101  0.230765  0.5  0.769235  0.95309\n",
       " 0.0469101  0.230765  0.5  0.769235  0.95309"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "5×5 Array{Float64,2}:\n",
       " 0.0140336  0.02835    0.0336963  0.02835    0.0140336\n",
       " 0.02835    0.0572714  0.0680716  0.0572714  0.02835  \n",
       " 0.0336963  0.0680716  0.0809086  0.0680716  0.0336963\n",
       " 0.02835    0.0572714  0.0680716  0.0572714  0.02835  \n",
       " 0.0140336  0.02835    0.0336963  0.02835    0.0140336"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "kubPoints, kubWeights=FEMCE.getKub(9, m.meshType);\n",
    "display(kubPoints);\n",
    "display(kubWeights);"
   ]
  },
  {
   "attachments": {
    "FERaeume.png": {
     "image/png": "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lj2fFCGdHA46IbC4QKoXlcVHEr+HEmKIj15LAukFSphTJcSQPrP2SCBeYChzyulY8TnWkgABAgQIECBAgACBCAFFSASaJgQIECBAgAABAgQIxAsoQuLttCRAgAABAgQIECBAIEJAERKBpgkBAgQIECBAgAABAvECipB4Oy0JECBAgAABAgQIEIgQUIREoGlCgAABAgQIECBAgEC8gCIk3k5LAgQIECBAgAABAgQiBBQhEWiaECBAgAABAgQIECAQL6AIibfTkgABAgQIECBAgACBCAFFSASaJgQIECBAgAABAgQIxAsoQuLttCRAgAABAgQIECBAIEJAERKBpgkBAgQIECBAgAABAvECipB4Oy0JECBAgAABAgQIEIgQUIREoGlCgAABAgQIECBAgEC8gCIk3k5LAgQIECBAgAABAgQiBBQhEWiaECBAgAABAgQIECAQL6AIibfTkgABAgQIECBAgACBCAFFSASaJgQIECBAgAABAgQIxAsoQuLttCRAgAABAgQIECBAIEJAERKBpgkBAgQIECBAgAABAvECipB4Oy0JECBAgAABAgQIEIgQUIREoGlCgAABAgQIECBAgEC8gCIk3k5LAgQIECBAgAABAgQiBBQhEWiaECBAgAABAgQIECAQL6AIibfTkgABAgQIECBAgACBCAFFSASaJgQIECBAgAABAgQIxAsoQuLttCRAgAABAgQIECBAIEJAERKBpgkBAgQIECBAgAABAvECipB4Oy0JECBAgAABAgQIEIgQUIREoGlCgAABAgQIECBAgEC8gCIk3k5LAgQIECBAgAABAgQiBBQhEWiaECBAgAABAgQIECAQL6AIibfTkgABAgQIECBAgACBCAFFSASaJgQIECBAgAABAgQIxAsoQuLttCRAgAABAgQIECBAIEJAERKBpgkBAgQIECBAgAABAvECipB4Oy0JECBAgAABAgQIEIgQUIREoGlCgAABAgQIECBAgEC8gCIk3k5LAgQIECBAgAABAgQiBBQhEWiaECBAgAABAgQIECAQL6AIibfTkgABAgQIECBAgACBCAFFSASaJgQIECBAgACBGgS+fPlSQ5hi7EFAEdIDui4JECBAgAABArkLfP36tdnZ2WnCrY1AagFFSGpR+yNAgAABAgQIFCDw4cOHJqyEvH//voBohJCbwMq379syBrWysjLe7ZJ2v4wh2yeBrAVKmFMlxJD1QWJw1QmUMKdKiKHEAy+sfrx+/Xq8CvLq1avm8+fPTbi15S8wlDllJST/Y8kICRAgQIAAAQKdCoRVkPY0rHBrNaRT/io6sxJSRZoFWYLAUP6yMcu6hBhmxecxAl0LlDCnSoih67wvu7+HqyBtX1ZDWon8b4cyp6yE5H8sGSEBAgQIECBAoDOBh6sgbadWQ1oJt6kErISkkrQfAksWGMpfNmYxlBDDrPg8RqBrgRLmVAkxdJ33ZfY3aRWk7c9qSCuR9+1Q5pSVkLyPI6MjQIAAAQIECHQmMGkVpO3cakgr4TaFwIsUO7EPAgQIECBAgACB4Qu8fPmyefv27X0gf/zxxw+/+4asexo/LCjgdKwFATUn0JXAUJZXZ3mUEMOs+DxGoGuBEuZUCTF0nfcu+wv5cbmFLsUX72soc8rpWIvn2h4IECBAgAABAgQIEJhDQBEyB5anEiBAgAABAgQIECCwuIAiZHFDeyBAgAABAgQIECBAYA4BRcgcWJ5KgAABAgQIECBAgMDiAoqQxQ3tgQABAgQIECBAgACBOQQUIXNgeSoBAgQIECBAgAABAosLJC9Crq+vm6Ojo/uRra2tNdvb2+P7wmM2AgSeL9DOp19//fW+kfl0T+EHAgQIECBAYKACSa8TcnZ21hwcHDQ3NzcTOdbX15uTk5NmNBpNfNydBAj8J1DifBrKd5f/lwU/EchboIQ5VUIMeR8li40u5Md1QhYz7Lr1UOZUsiIkvGHa399/8kANMKenpwqRro9I/Q1KoNT5NJQXxkEdLAZbtUAJc6qEGEo+CEN+FCHDyvBQ5lSSIiScMrK1tTV1BeRx6sKKyOXlZbOxsfH4Ib8TqF6g5Pk0lBfG6g9CAIMRKGFOlRDDYA6YiIGG/ChCIuB6bDKUOZXkMyHHx8fPLkBCTsLpWqGNjQCBnwXMp59N3EOAAAECBAiUJZCkCDk/P59b5eLiYu42GhCoQcB8qiHLYiRAgAABAnULJDkdK3wD1t3d3VySq6urze3t7VxtPJlADQIlz6ehLBHXcJyJsQyBEuZUCTGUcTRNjiLkx+lYk21yvXcoc+pFX4ChaGmR+hqDfgkQIECAAAECBAgQ6F4gyelYm5ub3Y9cjwQI3AuEL4awESBAgAABAgSGIpCkCNnb25s73jdv3oyX98ISn38MHAP/HQNhbsy77e7uztvE8wkQIECAwJMCTsV6ksgTIgWSfCak5K8UjXTVjEC0QMnzySmY0YeFhgRmCgz5jaLXhZmp9SCBaIHcXxeSrISE632EK6E/54UkPCc81zVCoo8pDQsXMJ8KT7DwCBAgQIAAgSbJSkjrGK7yfHBwMPWaIeEihaEAGY1GbRO3BAhMETCfpsC4mwABAgQIEBi8QNIiJGiEU0nCxdbCtQ6urq7GQOFDs+Gc9cPDQysggz9kBNClgPnUpba+CBAgQIAAga4EkhchXQ1cPwQIECBAgAABAgQIDFMgyWdChhm6URMgQIAAAQIECBAg0IeAIqQPdX0SIECAAAECBAgQqFhAEVJx8oVOgAABAgQIECBAoA8BRUgf6vokQIAAAQIECBAgULGAIqTi5AudAAECBAgQIECAQB8CipA+1PVJgAABAgQIECBAoGIBRUjFyRc6AQIECBAgQIAAgT4EFCF9qOuTAAECBAgQIECAQMUCipCKky90AgQIECBAgAABAn0IKEL6UNcnAQIECBAgQIAAgYoFFCEVJ1/oBAgQIECAAAECBPoQUIT0oa5PAgQIECBAgAABAhULKEIqTr7QCRAgQIAAAQIECPQh8H/HVtNEZ8KvkAAAAABJRU5ErkJggg=="
    }
   },
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Defining the nodal functions $ \\left\\lbrace \\phi_{i} \\right\\rbrace_{i=1}^{n} $ and degrees of freedom for the finite element:![FERaeume.png](attachment:FERaeume.png)\n",
    "Shown here f.l.t.r.: P1, DG0, RT0"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "So P1 has the nodal functions on the unit square as the reference element:\n",
    "\\begin{align*}\n",
    "\\phi_{1}(x)&=(1-x_{1})(1-x_{2}) \\\\\n",
    "\\phi_{2}(x)&=x_{1}(1-x_{2}) \\\\\n",
    "\\phi_{3}(x)&=x_{1}x_{2} \\\\\n",
    "\\phi_{4}(x)&=(1-x_{1})x_{2}\n",
    "\\end{align*}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 71,
   "metadata": {},
   "outputs": [],
   "source": [
    "boundary=FEMCE.getBoundary(m);\n",
    "b=Set{Int64}(collect(keys(boundary)));\n",
    "degF=FEMCE.degF(m,:P1,boundary,b,kubPoints);"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 110,
   "metadata": {
    "collapsed": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "5×5 Array{Float64,2}:\n",
       " 0.90838    0.73315    0.476545  0.21994    0.0447095 \n",
       " 0.73315    0.591722   0.384617  0.177513   0.0360849 \n",
       " 0.476545   0.384617   0.25      0.115383   0.023455  \n",
       " 0.21994    0.177513   0.115383  0.0532526  0.0108252 \n",
       " 0.0447095  0.0360849  0.023455  0.0108252  0.00220056"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "5×5 Array{Float64,2}:\n",
       " 0.0447095  0.0360849  0.023455  0.0108252  0.00220056\n",
       " 0.21994    0.177513   0.115383  0.0532526  0.0108252 \n",
       " 0.476545   0.384617   0.25      0.115383   0.023455  \n",
       " 0.73315    0.591722   0.384617  0.177513   0.0360849 \n",
       " 0.90838    0.73315    0.476545  0.21994    0.0447095 "
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "5×5 Array{Float64,2}:\n",
       " 0.0447095   0.21994    0.476545  0.73315    0.90838  \n",
       " 0.0360849   0.177513   0.384617  0.591722   0.73315  \n",
       " 0.023455    0.115383   0.25      0.384617   0.476545 \n",
       " 0.0108252   0.0532526  0.115383  0.177513   0.21994  \n",
       " 0.00220056  0.0108252  0.023455  0.0360849  0.0447095"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "5×5 Array{Float64,2}:\n",
       " 0.00220056  0.0108252  0.023455  0.0360849  0.0447095\n",
       " 0.0108252   0.0532526  0.115383  0.177513   0.21994  \n",
       " 0.023455    0.115383   0.25      0.384617   0.476545 \n",
       " 0.0360849   0.177513   0.384617  0.591722   0.73315  \n",
       " 0.0447095   0.21994    0.476545  0.73315    0.90838  "
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "for i in 1:length(degF.phi)\n",
    "    display(degF.phi[i])\n",
    "end"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Randomly generating the values at the degrees of freedom:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 72,
   "metadata": {},
   "outputs": [],
   "source": [
    "val=rand(m.topology.size[1]);"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Defining a function that calculates the value of the ansatz for a variable $b=\\sum_{j=1}^{N} v_{j} \\, \\phi_{j}$ for each cell:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 153,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "getIndices (generic function with 1 method)"
      ]
     },
     "execution_count": 153,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "function testAllocations(degF::FEMCE.degF{1},val::Array{Float64,1},m::mesh,kubWeights::Array{Float64,2})\n",
    "    phi=degF.phi;\n",
    "    sk=size(kubWeights);\n",
    "    for k in 1:m.topology.size[3]\n",
    "        ind=getIndices(degF.incidence,degF.offset,k);\n",
    "        w=zeros(sk);\n",
    "        for i in 1:length(ind)\n",
    "            w+=val[ind[i]]*phi[i];\n",
    "        end\n",
    "    end\n",
    "    return nothing;\n",
    "end\n",
    "\n",
    "function getIndices(incidence::Array{Int64,1},offset::Array{Int64,1},k::Int64)\n",
    "    return incidence[offset[k]:offset[k+1]-1];\n",
    "end"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 155,
   "metadata": {
    "collapsed": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "  0.064008 seconds (50.00 k allocations: 12.894 MiB, 29.70% gc time)\n"
     ]
    }
   ],
   "source": [
    "@time testAllocations(degF,val,m,kubWeights);"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**GOAL: Minimzing these allocations!**"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Accessing phi via @views, instead of copying the arrays:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "testAllocations (generic function with 1 method)"
      ]
     },
     "execution_count": 27,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "function testAllocations(degF::FEMCE.degF{1},val::Array{Float64,1},m::mesh,kubWeights::Array{Float64,2})\n",
    "    phi=@views degF.phi;\n",
    "    sk=size(kubWeights);\n",
    "    for k in 1:m.topology.size[3]\n",
    "        ind=getIndices(degF.incidence,degF.offset,k);\n",
    "        w=zeros(sk);\n",
    "        for i in 1:length(ind)\n",
    "            w+=val[ind[i]]* phi[i];\n",
    "        end\n",
    "    end\n",
    "    return nothing;\n",
    "end"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {
    "collapsed": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "  0.220228 seconds (123.38 k allocations: 26.978 MiB, 10.90% gc time)\n"
     ]
    }
   ],
   "source": [
    "@time testAllocations(degF,val,m,kubWeights);"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Avoid allocating the array w in each iteration of the loop:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "testAllocations (generic function with 1 method)"
      ]
     },
     "execution_count": 31,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "function testAllocations(degF::FEMCE.degF{1},val::Array{Float64,1},m::mesh,kubWeights::Array{Float64,2})\n",
    "    phi=@views degF.phi;\n",
    "    sk=size(kubWeights);\n",
    "    w=zeros(sk);\n",
    "    for k in 1:m.topology.size[3]\n",
    "        ind=getIndices(degF.incidence,degF.offset,k);\n",
    "        fill!(w,0.0);\n",
    "        for i in 1:length(ind)\n",
    "            w+=val[ind[i]]*phi[i];\n",
    "        end\n",
    "    end\n",
    "    return nothing;\n",
    "end"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {
    "collapsed": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "  0.080908 seconds (113.72 k allocations: 24.248 MiB, 29.69% gc time)\n"
     ]
    }
   ],
   "source": [
    "@time testAllocations(degF,val,m,kubWeights);"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Optimizing the addition of the arrays w and phi[i] by using dotwise operations"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "testAllocations (generic function with 1 method)"
      ]
     },
     "execution_count": 35,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "function testAllocations(degF::FEMCE.degF{1},val::Array{Float64,1},m::mesh,kubWeights::Array{Float64,2})\n",
    "    phi=@views degF.phi;\n",
    "    sk=size(kubWeights);\n",
    "    w=zeros(sk);\n",
    "    for k in 1:m.topology.size[3]\n",
    "        ind=getIndices(degF.incidence,degF.offset,k);\n",
    "        fill!(w,0.0);\n",
    "        for i in 1:length(ind)\n",
    "            @. w+=val[ind[i]]*phi[i];\n",
    "        end\n",
    "    end\n",
    "    return nothing;\n",
    "end"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {
    "collapsed": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "  0.122041 seconds (55.75 k allocations: 3.149 MiB)\n"
     ]
    }
   ],
   "source": [
    "@time testAllocations(degF,val,m,kubWeights);"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Turning getIndices() into a mutating function:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 76,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "getIndices! (generic function with 1 method)"
      ]
     },
     "execution_count": 76,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "function testAllocations(degF::FEMCE.degF{1},val::Array{Float64,1},m::mesh,kubWeights::Array{Float64,2})\n",
    "    phi=@views degF.phi;\n",
    "    sk=size(kubWeights);\n",
    "    w=zeros(sk);\n",
    "    ind=Array{Int64,1}(undef,length(phi));\n",
    "    for k in 1:m.topology.size[3]\n",
    "        getIndices!(ind,degF.incidence,degF.offset,k);\n",
    "        fill!(w,0.0);\n",
    "        for i in 1:length(ind)\n",
    "            @. w+=val[ind[i]]*phi[i];\n",
    "        end\n",
    "    end\n",
    "    return nothing;\n",
    "end\n",
    "function getIndices!(ind::Array{Int64,1},incidence::Array{Int64,1},offset::Array{Int64,1},k::Int64)\n",
    "    ind=incidence[offset[k]:offset[k+1]-1];\n",
    "    return nothing;\n",
    "end"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "metadata": {
    "collapsed": true
   },
   "outputs": [
    {
     "ename": "BoundsError",
     "evalue": "BoundsError: attempt to access 10201-element Array{Float64,1} at index [4620635440]",
     "output_type": "error",
     "traceback": [
      "BoundsError: attempt to access 10201-element Array{Float64,1} at index [4620635440]",
      "",
      "Stacktrace:",
      " [1] getindex at ./array.jl:729 [inlined]",
      " [2] testAllocations(::FEMCE.degF{1}, ::Array{Float64,1}, ::mesh, ::Array{Float64,2}) at ./In[50]:10",
      " [3] top-level scope at util.jl:156",
      " [4] top-level scope at In[51]:1"
     ]
    }
   ],
   "source": [
    "@time testAllocations(degF,val,m,kubWeights);"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "But how can we change it to a mutating function?\n",
    "- Mutable Data Type\n",
    "- You need to change what the object contains, not just what the name points to!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "getIndices! (generic function with 1 method)"
      ]
     },
     "execution_count": 52,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "function getIndices!(ind::Array{Int64,1},incidence::Array{Int64,1},offset::Array{Int64,1},k::Int64)\n",
    "    ind[:]=incidence[offset[k]:offset[k+1]-1];\n",
    "    return nothing;\n",
    "end"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "metadata": {
    "collapsed": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "  0.179649 seconds (69.60 k allocations: 3.746 MiB, 13.34% gc time)\n"
     ]
    }
   ],
   "source": [
    "@time testAllocations(degF,val,m,kubWeights);"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Using a for loop instead of a slice:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 77,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "getIndices! (generic function with 1 method)"
      ]
     },
     "execution_count": 77,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "function getIndices!(ind::Array{Int64,1},incidence::Array{Int64,1},offset::Array{Int64,1},k::Int64)\n",
    "    z=1;\n",
    "    for i=offset[k]:offset[k+1]-1\n",
    "        ind[z]=incidence[i];\n",
    "        z+=1;\n",
    "    end\n",
    "    return nothing;\n",
    "end"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 79,
   "metadata": {
    "collapsed": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "  0.004670 seconds (6 allocations: 560 bytes)\n"
     ]
    }
   ],
   "source": [
    "@time testAllocations(degF,val,m,kubWeights);"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Since storing phi as an Array{Array{Float64,2},1} is not optimal, we want to change the data type of phi to Array{Float64,3} and check if this is actually preferable."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To test this, we define a function that changes the data type of phi accordingly:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 80,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "hdimarray (generic function with 1 method)"
      ]
     },
     "execution_count": 80,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "function hdimarray(s::Array{Array{Float64,2},1})\n",
    "    sh=Array{Float64,3}(undef,size(s[1],1),size(s[1],2),length(s));\n",
    "    for k in 1:length(s)\n",
    "        for j in 1:size(s[1],2)\n",
    "            for i in 1:size(s[1],1)\n",
    "                sh[i,j,k]=s[k][i,j]\n",
    "            end\n",
    "        end\n",
    "    end\n",
    "    return sh;\n",
    "end"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 117,
   "metadata": {},
   "outputs": [],
   "source": [
    "phi=hdimarray(degF.phi);"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Adapting the test function accordingly:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 112,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "testAllocations (generic function with 5 methods)"
      ]
     },
     "execution_count": 112,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "function testAllocations(phi::Array{Float64,3},degF::FEMCE.degF{1},val::Array{Float64,1},m::mesh,kubWeights::Array{Float64,2})\n",
    "    sk=size(kubWeights);\n",
    "    w=zeros(sk);\n",
    "    ind=Array{Int64,1}(undef,size(phi,3));\n",
    "    for k in 1:m.topology.size[3]\n",
    "        getIndices!(ind,degF.incidence,degF.offset,k);\n",
    "        fill!(w,0.0);\n",
    "        for i in 1:length(ind)\n",
    "            @. w+=val[ind[i]]* phi[:,:,i];\n",
    "        end\n",
    "    end\n",
    "    return nothing;\n",
    "end"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 116,
   "metadata": {
    "collapsed": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "  0.016615 seconds (20.01 k allocations: 5.494 MiB)\n"
     ]
    }
   ],
   "source": [
    "@time testAllocations(phi,degF,val,m,kubWeights);"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We again have allocation issues. But why?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Again replacing slices with a for loop:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 118,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "testAllocations (generic function with 5 methods)"
      ]
     },
     "execution_count": 118,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "function testAllocations(phi::Array{Float64,3},degF::FEMCE.degF{1},val::Array{Float64,1},m::mesh,kubWeights::Array{Float64,2})\n",
    "    sk=size(kubWeights);\n",
    "    w=zeros(sk);\n",
    "    ind=Array{Int64,1}(undef,size(phi,3));\n",
    "    for k in 1:m.topology.size[3]\n",
    "        getIndices!(ind,degF.incidence,degF.offset,k);\n",
    "        fill!(w,0.0);\n",
    "        for i in 1:length(ind)\n",
    "            for j in 1:sk[2]\n",
    "                for k in 1:sk[1]\n",
    "                    w[k,j]+=val[ind[i]]* phi[k,j,i];\n",
    "                end\n",
    "            end\n",
    "\n",
    "        end\n",
    "    end\n",
    "    return nothing;\n",
    "end"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 120,
   "metadata": {
    "collapsed": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "  0.003136 seconds (6 allocations: 560 bytes)\n"
     ]
    }
   ],
   "source": [
    "@time testAllocations(phi,degF,val,m,kubWeights);"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Results for our code:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "  0.104294 seconds (16 allocations: 4.359 KiB)\n",
      "  0.171721 seconds (16 allocations: 4.359 KiB)\n",
      "  0.149442 seconds (16 allocations: 4.359 KiB)\n",
      "2.0\n"
     ]
    }
   ],
   "source": [
    "FEMCE.testWarmBubble();"
   ]
  }
 ],
 "metadata": {
  "@webio": {
   "lastCommId": null,
   "lastKernelId": null
  },
  "kernelspec": {
   "display_name": "Julia 1.1.0",
   "language": "julia",
   "name": "julia-1.1"
  },
  "language_info": {
   "file_extension": ".jl",
   "mimetype": "application/julia",
   "name": "julia",
   "version": "1.1.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
